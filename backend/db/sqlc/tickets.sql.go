// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: tickets.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTicket = `-- name: CreateTicket :one
INSERT INTO tickets (
  flight_class,
  price,
  status,
  booking_id,
  flight_id
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING ticket_id, seat_id, flight_class, price, status, booking_id, flight_id, created_at, updated_at
`

type CreateTicketParams struct {
	FlightClass FlightClass  `json:"flight_class"`
	Price       int32        `json:"price"`
	Status      TicketStatus `json:"status"`
	BookingID   pgtype.Int8  `json:"booking_id"`
	FlightID    pgtype.Int8  `json:"flight_id"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (Ticket, error) {
	row := q.db.QueryRow(ctx, createTicket,
		arg.FlightClass,
		arg.Price,
		arg.Status,
		arg.BookingID,
		arg.FlightID,
	)
	var i Ticket
	err := row.Scan(
		&i.TicketID,
		&i.SeatID,
		&i.FlightClass,
		&i.Price,
		&i.Status,
		&i.BookingID,
		&i.FlightID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTicket = `-- name: DeleteTicket :exec
DELETE FROM tickets
WHERE ticket_id = $1
`

func (q *Queries) DeleteTicket(ctx context.Context, ticketID int64) error {
	_, err := q.db.Exec(ctx, deleteTicket, ticketID)
	return err
}

const getTicket = `-- name: GetTicket :one
SELECT ticket_id, seat_id, flight_class, price, status, booking_id, flight_id, created_at, updated_at FROM tickets
WHERE ticket_id = $1 LIMIT 1
`

func (q *Queries) GetTicket(ctx context.Context, ticketID int64) (Ticket, error) {
	row := q.db.QueryRow(ctx, getTicket, ticketID)
	var i Ticket
	err := row.Scan(
		&i.TicketID,
		&i.SeatID,
		&i.FlightClass,
		&i.Price,
		&i.Status,
		&i.BookingID,
		&i.FlightID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTicketByFlightId = `-- name: GetTicketByFlightId :many
SELECT ticket_id, seat_id, flight_class, price, status, booking_id, flight_id, created_at, updated_at FROM tickets
WHERE flight_id = $1
ORDER BY ticket_id
`

func (q *Queries) GetTicketByFlightId(ctx context.Context, flightID pgtype.Int8) ([]Ticket, error) {
	rows, err := q.db.Query(ctx, getTicketByFlightId, flightID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.TicketID,
			&i.SeatID,
			&i.FlightClass,
			&i.Price,
			&i.Status,
			&i.BookingID,
			&i.FlightID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketByID = `-- name: GetTicketByID :one
SELECT
    t.ticket_id,
    t.seat_id,
    t.status,
    t.flight_class,
    t.price,
    t.booking_id,
    t.flight_id,
    t.created_at,
    t.updated_at,
    s.seat_code,
    s.class AS seat_class,
    tos.first_name,
    tos.last_name,
    tos.phone_number,
    tos.gender
FROM Tickets t
JOIN Seats s ON t.seat_id = s.seat_id
JOIN TicketOwnerSnapshot tos ON t.ticket_id = tos.ticket_id
WHERE t.ticket_id = $1
LIMIT 1
`

type GetTicketByIDRow struct {
	TicketID    int64        `json:"ticket_id"`
	SeatID      pgtype.Int8  `json:"seat_id"`
	Status      TicketStatus `json:"status"`
	FlightClass FlightClass  `json:"flight_class"`
	Price       int32        `json:"price"`
	BookingID   pgtype.Int8  `json:"booking_id"`
	FlightID    pgtype.Int8  `json:"flight_id"`
	CreatedAt   time.Time    `json:"created_at"`
	UpdatedAt   time.Time    `json:"updated_at"`
	SeatCode    string       `json:"seat_code"`
	SeatClass   FlightClass  `json:"seat_class"`
	FirstName   pgtype.Text  `json:"first_name"`
	LastName    pgtype.Text  `json:"last_name"`
	PhoneNumber pgtype.Text  `json:"phone_number"`
	Gender      GenderType   `json:"gender"`
}

func (q *Queries) GetTicketByID(ctx context.Context, ticketID int64) (GetTicketByIDRow, error) {
	row := q.db.QueryRow(ctx, getTicketByID, ticketID)
	var i GetTicketByIDRow
	err := row.Scan(
		&i.TicketID,
		&i.SeatID,
		&i.Status,
		&i.FlightClass,
		&i.Price,
		&i.BookingID,
		&i.FlightID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SeatCode,
		&i.SeatClass,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Gender,
	)
	return i, err
}

const getTicketsByFlightID = `-- name: GetTicketsByFlightID :many
SELECT
    t.ticket_id,
    t.status,
    t.flight_class,
    t.price,
    t.booking_id,
    t.flight_id,
    t.created_at,
    t.updated_at,
    tos.first_name,
    tos.last_name,
    tos.phone_number,
    tos.gender,
    s.seat_code,
    s.class AS seat_class
FROM Tickets t
LEFT JOIN TicketOwnerSnapshot tos ON t.ticket_id = tos.ticket_id
LEFT JOIN Seats s ON t.flight_id = s.flight_id
WHERE t.flight_id = $1
`

type GetTicketsByFlightIDRow struct {
	TicketID    int64           `json:"ticket_id"`
	Status      TicketStatus    `json:"status"`
	FlightClass FlightClass     `json:"flight_class"`
	Price       int32           `json:"price"`
	BookingID   pgtype.Int8     `json:"booking_id"`
	FlightID    pgtype.Int8     `json:"flight_id"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
	FirstName   pgtype.Text     `json:"first_name"`
	LastName    pgtype.Text     `json:"last_name"`
	PhoneNumber pgtype.Text     `json:"phone_number"`
	Gender      NullGenderType  `json:"gender"`
	SeatCode    pgtype.Text     `json:"seat_code"`
	SeatClass   NullFlightClass `json:"seat_class"`
}

func (q *Queries) GetTicketsByFlightID(ctx context.Context, flightID pgtype.Int8) ([]GetTicketsByFlightIDRow, error) {
	rows, err := q.db.Query(ctx, getTicketsByFlightID, flightID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTicketsByFlightIDRow{}
	for rows.Next() {
		var i GetTicketsByFlightIDRow
		if err := rows.Scan(
			&i.TicketID,
			&i.Status,
			&i.FlightClass,
			&i.Price,
			&i.BookingID,
			&i.FlightID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.Gender,
			&i.SeatCode,
			&i.SeatClass,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTickets = `-- name: ListTickets :many
SELECT ticket_id, seat_id, flight_class, price, status, booking_id, flight_id, created_at, updated_at FROM tickets
ORDER BY ticket_id
LIMIT $1
OFFSET $2
`

type ListTicketsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTickets(ctx context.Context, arg ListTicketsParams) ([]Ticket, error) {
	rows, err := q.db.Query(ctx, listTickets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.TicketID,
			&i.SeatID,
			&i.FlightClass,
			&i.Price,
			&i.Status,
			&i.BookingID,
			&i.FlightID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicket = `-- name: UpdateTicket :exec
UPDATE tickets
SET
  flight_class = $2,
  price = $3,
  status = $4,
  booking_id = $5,
  flight_id = $6,
  updated_at = NOW()
WHERE ticket_id = $1
`

type UpdateTicketParams struct {
	TicketID    int64        `json:"ticket_id"`
	FlightClass FlightClass  `json:"flight_class"`
	Price       int32        `json:"price"`
	Status      TicketStatus `json:"status"`
	BookingID   pgtype.Int8  `json:"booking_id"`
	FlightID    pgtype.Int8  `json:"flight_id"`
}

func (q *Queries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) error {
	_, err := q.db.Exec(ctx, updateTicket,
		arg.TicketID,
		arg.FlightClass,
		arg.Price,
		arg.Status,
		arg.BookingID,
		arg.FlightID,
	)
	return err
}

const updateTicketStatus = `-- name: UpdateTicketStatus :one
UPDATE Tickets
SET status = $2, updated_at = NOW()
WHERE ticket_id = $1
RETURNING ticket_id, seat_id, flight_class, price, status, booking_id, flight_id, created_at, updated_at
`

type UpdateTicketStatusParams struct {
	TicketID int64        `json:"ticket_id"`
	Status   TicketStatus `json:"status"`
}

func (q *Queries) UpdateTicketStatus(ctx context.Context, arg UpdateTicketStatusParams) (Ticket, error) {
	row := q.db.QueryRow(ctx, updateTicketStatus, arg.TicketID, arg.Status)
	var i Ticket
	err := row.Scan(
		&i.TicketID,
		&i.SeatID,
		&i.FlightClass,
		&i.Price,
		&i.Status,
		&i.BookingID,
		&i.FlightID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
