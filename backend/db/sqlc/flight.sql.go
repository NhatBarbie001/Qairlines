// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: flight.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFlight = `-- name: CreateFlight :one
INSERT INTO flight (
  flight_number,
  registration_number,
  estimated_departure_time,
  actual_departure_time,
  estimated_arrival_time,
  actual_arrival_time,
  departure_airport_id,
  destination_airport_id,
  flight_price,
  status
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING flight_id, flight_number, registration_number, estimated_departure_time, actual_departure_time, estimated_arrival_time, actual_arrival_time, departure_airport_id, destination_airport_id, flight_price, status
`

type CreateFlightParams struct {
	FlightNumber           string           `json:"flight_number"`
	RegistrationNumber     string           `json:"registration_number"`
	EstimatedDepartureTime pgtype.Timestamp `json:"estimated_departure_time"`
	ActualDepartureTime    pgtype.Timestamp `json:"actual_departure_time"`
	EstimatedArrivalTime   pgtype.Timestamp `json:"estimated_arrival_time"`
	ActualArrivalTime      pgtype.Timestamp `json:"actual_arrival_time"`
	DepartureAirportID     int64            `json:"departure_airport_id"`
	DestinationAirportID   int64            `json:"destination_airport_id"`
	FlightPrice            pgtype.Numeric   `json:"flight_price"`
	Status                 FlightStatus     `json:"status"`
}

func (q *Queries) CreateFlight(ctx context.Context, arg CreateFlightParams) (Flight, error) {
	row := q.db.QueryRow(ctx, createFlight,
		arg.FlightNumber,
		arg.RegistrationNumber,
		arg.EstimatedDepartureTime,
		arg.ActualDepartureTime,
		arg.EstimatedArrivalTime,
		arg.ActualArrivalTime,
		arg.DepartureAirportID,
		arg.DestinationAirportID,
		arg.FlightPrice,
		arg.Status,
	)
	var i Flight
	err := row.Scan(
		&i.FlightID,
		&i.FlightNumber,
		&i.RegistrationNumber,
		&i.EstimatedDepartureTime,
		&i.ActualDepartureTime,
		&i.EstimatedArrivalTime,
		&i.ActualArrivalTime,
		&i.DepartureAirportID,
		&i.DestinationAirportID,
		&i.FlightPrice,
		&i.Status,
	)
	return i, err
}

const deleteFlight = `-- name: DeleteFlight :exec
DELETE FROM flight
WHERE flight_number = $1
`

func (q *Queries) DeleteFlight(ctx context.Context, flightNumber string) error {
	_, err := q.db.Exec(ctx, deleteFlight, flightNumber)
	return err
}

const getFlight = `-- name: GetFlight :one
SELECT flight_id, flight_number, registration_number, estimated_departure_time, actual_departure_time, estimated_arrival_time, actual_arrival_time, departure_airport_id, destination_airport_id, flight_price, status FROM flight
WHERE flight_id = $1 LIMIT 1
`

func (q *Queries) GetFlight(ctx context.Context, flightID int64) (Flight, error) {
	row := q.db.QueryRow(ctx, getFlight, flightID)
	var i Flight
	err := row.Scan(
		&i.FlightID,
		&i.FlightNumber,
		&i.RegistrationNumber,
		&i.EstimatedDepartureTime,
		&i.ActualDepartureTime,
		&i.EstimatedArrivalTime,
		&i.ActualArrivalTime,
		&i.DepartureAirportID,
		&i.DestinationAirportID,
		&i.FlightPrice,
		&i.Status,
	)
	return i, err
}

const listFlights = `-- name: ListFlights :many
SELECT flight_id, flight_number, registration_number, estimated_departure_time, actual_departure_time, estimated_arrival_time, actual_arrival_time, departure_airport_id, destination_airport_id, flight_price, status FROM flight
ORDER BY flight_number
LIMIT $1
OFFSET $2
`

type ListFlightsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListFlights(ctx context.Context, arg ListFlightsParams) ([]Flight, error) {
	rows, err := q.db.Query(ctx, listFlights, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Flight
	for rows.Next() {
		var i Flight
		if err := rows.Scan(
			&i.FlightID,
			&i.FlightNumber,
			&i.RegistrationNumber,
			&i.EstimatedDepartureTime,
			&i.ActualDepartureTime,
			&i.EstimatedArrivalTime,
			&i.ActualArrivalTime,
			&i.DepartureAirportID,
			&i.DestinationAirportID,
			&i.FlightPrice,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
